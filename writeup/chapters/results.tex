\chapter{Results} \label{chp:results}
\section{Introduction} \label{sec:results/introduction}
In this chapter, the results of using Locomotion on the benchmarks presented in section \ref{sec:methodology/benchmarks} are presented, along with a critical analysis of the results.

\section{Basic Testing} \label{sec:results/basic}
The first testing that was conduct was to determine the correct operation of the instrumentation and runtime library. Several tests were constructed in order to test at the extremes (for edge cases) of dependency analysis - every access is dependent, and no access is dependent.

The algorithm used to create these tests is similar to that presented in chapter \ref{chp:parametric}, with some slight modifications to produce the desired test configurations.

The methodology used has been described in chapter \ref{chp:methodology}.

	\subsection{No Dependencies} \label{sec:result/basic/no-dep}
	We first consider the case of where no dependencies are detected. We observed the following results for the exact and inexact storage mechanisms as described in section \ref{sec:runtime/storage}.
	
	\begin{figure}[H]
		\centering
		\begin{gnuplot}[terminal=pdf]
		set multiplot layout 1, 2
		
		load '../charts/none-dependent_length-deps_HashSetTrace-with-instrument.gnuplot'
		load '../charts/none-dependent_size-deps_BloomFilterTrace-with-instrument.gnuplot'
		
		unset multiplot
		\end{gnuplot}
		\label{chart:none-dependent-deps-comparison}
		\caption{No dependencies with hash set and bloom filter storage}
	\end{figure}
	
	As we can see, there are (correctly) no dependencies detected.
	
	Next, we consider the memory usage of detecting these dependencies. Of course, we must still retain a data structure for all previous accesses (recall from section \ref{sec:runtime/storage/exact/hashing} that this scales $S=O(n)$).
	
	\begin{figure}[H]
		\centering
		\begin{gnuplot}[terminal=pdf]
			set multiplot layout 1,2
				load '../charts/none-dependent_length-memory_HashSetTrace-with-instrument.gnuplot'
				load '../charts/none-dependent_size-memory_BloomFilterTrace-with-instrument.gnuplot'
			unset multiplot
		\end{gnuplot}
		\label{chart:none-dependent-memory-comparison}
		\caption{Memory usage for no dependencies found}
	\end{figure}
	
	We can see that, as expected, the storage space required when using exact storage does indeed increase almost linearly as a function of the number of accesses increases.
	
	Additionally, we can see that as the number of accesses the amount of memory required for the bloom filter implementation. Although not visible on this graph due to the scale, the required memory for bit vector size increases also scales almost linearly with the bit vector size. We will investigate this in a later section.
	
	\subsection{All Dependent} \label{sec:result/basic/all-dep}
	Next, the instrumentation is tested when all of the accesses are dependent. In this case, the dependencies are $\delta^{0}$ dependencies, but this does not effect the results.
	
	\begin{figure}[H]
		\begin{gnuplot}[terminal=pdf]
			set multiplot layout 1,2
				load '../charts/all-dependent_length-deps_HashSetTrace-with-instrument.gnuplot'
				load '../charts/all-dependent_size-deps_BloomFilterTrace-with-instrument.gnuplot'		
			unset multiplot
		\end{gnuplot}
		\label{chart:all-dependent-deps-comparison}
		\caption{Overview of the dependencies detected when all iterations are dependent}.
	\end{figure}
	
	We can see here that for both trace formats, the correct number of dependencies are detected. For the bloom filter, this is due to the `no false negative' property - a false negative, in this case, is wrongly reporting that an access has not been seen before.
	
	\begin{figure}[H]
		\begin{gnuplot}[terminal=pdf]
		set multiplot layout 1,2
			load '../charts/all-dependent_length-memory_HashSetTrace-with-instrument.gnuplot'
			load '../charts/all-dependent_size-memory_BloomFilterTrace-with-instrument.gnuplot'
					unset multiplot
		\end{gnuplot}
		\caption{Overview of the memory usage when all iterations are dependent}
		\label{chart:all-dependent-memory-comparison}
	\end{figure}
	
	From figure \ref{chart:all-dependent-memory-comparison}, we can begin to see the results of using a bloom filter. When the memory usage is compared, we notice that the bloom filter is significantly lower.
	
	From these memory usage results we can also begin to understand why memory usage measurement is so difficult in the JVM -- there are several anomalies in both datasets. This is likely due to the unpredictable/non-deterministic nature of the garbage collection algorithm, as well as the OS memory allocation mechanism. However, when we only take into account the non-anomalous results and see the overall trends, we see a clear pattern already -- bloom filters offer a significant memory usage improvement over sets.
	
	In these experiments, we used a fixed $ffp$ of 0.03. In later experiments, this value will be modified in order to determine the optimal configuration for the bloom filter.
	

\section{Parametric} \label{sec:results/parametric}
See chapter \ref{chp:parametric}.

\section{N-Body} \label{sec:results/nbody}

\section{Graph Processing} \label{sec:results/graph}

\section{Java Grande} \label{sec:results/grande}

\section{Overhead} \label{sec:results/overhead}
	\subsection{Execution Time} \label{sec:results/overhead/time}
	
	\subsection{Memory Usage} \label{sec:results/overhead/memory}

\section{Analysis} \label{sec:results/analysis}

\section{Summary} \label{sec:results/summary}